<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹¤ì‹œê°„ ì–¼êµ´ ì¸¡ì • ì‹œìŠ¤í…œ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 1400px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            margin-bottom: 20px;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        #video, #canvas {
            width: 100%;
            height: auto;
            display: block;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .measurements {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .measurement-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            transition: transform 0.3s ease;
        }

        .measurement-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .measurement-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .measurement-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #333;
            display: flex;
            align-items: baseline;
            gap: 10px;
        }

        .measurement-unit {
            font-size: 0.6em;
            color: #999;
        }

        .status {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: normal;
            margin-left: 10px;
        }

        .status.normal {
            background: #d4edda;
            color: #155724;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
        }

        .status.abnormal {
            background: #f8d7da;
            color: #721c24;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(102, 126, 234, 0.5);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        .trajectory-canvas {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            margin-top: 15px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }

        .capture-info {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }

        .capture-info h3 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #666;
        }

        .calibration-info {
            background: #fff9c4;
            border-left: 4px solid #fbc02d;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¬ ì‹¤ì‹œê°„ ì–¼êµ´ ì¸¡ì • ì‹œìŠ¤í…œ</h1>
        
        <div class="calibration-info">
            <strong>ğŸ“ ìº˜ë¦¬ë¸Œë ˆì´ì…˜:</strong> ì¹´ë©”ë¼ë¡œë¶€í„° ì•½ 30cm ê±°ë¦¬ì—ì„œ ì¸¡ì •í•˜ì„¸ìš”. 
            ì •í™•í•œ mm ë‹¨ìœ„ ì¸¡ì •ì„ ìœ„í•´ í‘œì¤€ ê±°ë¦¬ë¥¼ ìœ ì§€í•´ì£¼ì„¸ìš”.
        </div>

        <div class="controls">
            <button id="startBtn">ğŸ“· ì¹´ë©”ë¼ ì‹œì‘</button>
            <button id="stopBtn" disabled>â¹ ì¤‘ì§€</button>
            <button id="resetBtn">ğŸ”„ ì´ˆê¸°í™”</button>
            <button id="captureBtn" disabled>ğŸ“¸ ìˆ˜ë™ ìº¡ì²˜</button>
			<button id="downloadBtn">ğŸ’¾ ì´ë¯¸ì§€ ì €ì¥</button>
			<button id="sendToStreamlitBtn" disabled>âœ… ë¶„ì„ ê²°ê³¼ ì œì¶œ</button>
        </div>

        <div class="main-content">
            <div class="video-container">
                <video id="video" autoplay></video>
                <canvas id="canvas"></canvas>
            </div>

            <div class="measurements">
                <h2 style="margin-bottom: 20px; color: #333;">ğŸ“Š ì‹¤ì‹œê°„ ì¸¡ì •ê°’</h2>
                
                <div class="measurement-item">
                    <div class="measurement-label">ì…ë²Œë¦¼ ê¸¸ì´</div>
                    <div class="measurement-value">
                        <span id="mouthOpen">0</span>
                        <span class="measurement-unit">mm</span>
                        <span id="mouthOpenStatus" class="status normal">ì •ìƒ</span>
                    </div>
                </div>

                <div class="measurement-item">
                    <div class="measurement-label">ì… ë„ˆë¹„</div>
                    <div class="measurement-value">
                        <span id="mouthWidth">0</span>
                        <span class="measurement-unit">mm</span>
                    </div>
                </div>

                <div class="measurement-item">
                    <div class="measurement-label">í¸ìœ„ (ì¢Œìš° í¸ì°¨)</div>
                    <div class="measurement-value">
                        <span id="deviation">0</span>
                        <span class="measurement-unit">mm</span>
                        <span id="deviationStatus" class="status normal">ì •ìƒ</span>
                    </div>
                </div>

                <div class="measurement-item">
                    <div class="measurement-label">ë³€ìœ„ (ì›€ì§ì„ ëˆ„ì )</div>
                    <div class="measurement-value">
                        <span id="displacement">0</span>
                        <span class="measurement-unit">mm</span>
                    </div>
                </div>

                <div class="measurement-item">
                    <div class="measurement-label">ìµœëŒ€ ì…ë²Œë¦¼</div>
                    <div class="measurement-value" style="color: #e91e63;">
                        <span id="maxMouthOpen">0</span>
                        <span class="measurement-unit">mm</span>
                    </div>
                </div>

                <canvas id="trajectoryCanvas" class="trajectory-canvas" width="350" height="200"></canvas>
                
                <div class="capture-info">
                    <h3>ğŸ“¸ ìë™ ìº¡ì²˜ ì •ë³´</h3>
                    <div id="captureStatus">ëŒ€ê¸° ì¤‘...</div>
                </div>
            </div>
        </div>
    </div>
	<script src="https://cdn.jsdelivr.net/gh/streamlit/streamlit/frontend/src/streamlit-component-lib.js"></script>
    <!-- MediaPipe FaceMesh ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // ì „ì—­ ë³€ìˆ˜ ì„ ì–¸
        let camera = null;
        let faceMesh = null;
        let isRunning = false;
        let maxMouthOpen = 0;
        let lastLowerLipPos = null;
        let totalDisplacement = 0;
        let trajectoryPoints = [];
        let capturedFrames = [];
        let autoCaptureDone = false;
		let jawPath = [];         // [{x, y}]
		let diagnosedThisCycle = false;
		let lastDiagnosis = null; // {label, severity, uiText, explain}
        // í”½ì…€ì„ mmë¡œ ë³€í™˜í•˜ëŠ” ìº˜ë¦¬ë¸Œë ˆì´ì…˜ íŒ©í„° (30cm ê±°ë¦¬ ê¸°ì¤€)
        const PIXEL_TO_MM = 0.264583; // 96 DPI ê¸°ì¤€, ê±°ë¦¬ ë³´ì • í¬í•¨
        
        // ì£¼ìš” ëœë“œë§ˆí¬ ì¸ë±ìŠ¤ (MediaPipe FaceMesh)
        const LANDMARKS = {
            upperLip: 13,      // ìƒìˆœ ì¤‘ì•™
            lowerLip: 14,      // í•˜ìˆœ ì¤‘ì•™
            mouthLeft: 61,     // ì… ì™¼ìª½
            mouthRight: 291,   // ì… ì˜¤ë¥¸ìª½
            chinBottom: 152,   // í„± ë
            noseTip: 1,        // ì½” ë
            leftEye: 33,       // ì™¼ìª½ ëˆˆ
            rightEye: 263      // ì˜¤ë¥¸ìª½ ëˆˆ
        };

        // DOM ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const trajectoryCanvas = document.getElementById('trajectoryCanvas');
        const trajectoryCtx = trajectoryCanvas.getContext('2d');
        
        // ë²„íŠ¼ ìš”ì†Œ
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const captureBtn = document.getElementById('captureBtn');
        
        // MediaPipe FaceMesh ì´ˆê¸°í™”
        function initializeFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onResults);
        }
        
        // ì¹´ë©”ë¼ ì‹œì‘
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 1280,
                        height: 720,
                        facingMode: 'user'
                    }
                });
                
                video.srcObject = stream;
                
                // ë¹„ë””ì˜¤ ë©”íƒ€ë°ì´í„° ë¡œë“œ í›„ ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    // Camera Utils ì´ˆê¸°í™”
                    camera = new Camera(video, {
                        onFrame: async () => {
                            if (isRunning && faceMesh) {
                                await faceMesh.send({ image: video });
                            }
                        },
                        width: 1280,
                        height: 720
                    });
                    
                    camera.start();
                    isRunning = true;
                    
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    captureBtn.disabled = false;
                };
                
            } catch (error) {
                console.error('ì¹´ë©”ë¼ ì ‘ê·¼ ì˜¤ë¥˜:', error);
                alert('ì¹´ë©”ë¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
            }
        }
        
        // ì¹´ë©”ë¼ ì¤‘ì§€
        function stopCamera() {
            if (camera) {
                camera.stop();
            }
            
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            isRunning = false;
            startBtn.disabled = false;
            stopBtn.disabled = true;
            captureBtn.disabled = true;
        }
        
        // ì¸¡ì •ê°’ ì´ˆê¸°í™”
        function resetMeasurements() {
            maxMouthOpen = 0;
            totalDisplacement = 0;
            trajectoryPoints = [];
            lastLowerLipPos = null;
            capturedFrames = [];
            autoCaptureDone = false;
            
            document.getElementById('mouthOpen').textContent = '0';
            document.getElementById('mouthWidth').textContent = '0';
            document.getElementById('deviation').textContent = '0';
            document.getElementById('displacement').textContent = '0';
            document.getElementById('maxMouthOpen').textContent = '0';
            document.getElementById('captureStatus').textContent = 'ëŒ€ê¸° ì¤‘...';
            
            // ê¶¤ì  ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
            trajectoryCtx.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);
        }
        
        // FaceMesh ê²°ê³¼ ì²˜ë¦¬
        function onResults(results) {
            // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks[0]) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // ì–¼êµ´ ë©”ì‹œ ê·¸ë¦¬ê¸°
                //drawFaceMesh(landmarks);
                
                // ì¸¡ì • ìˆ˜í–‰
                performMeasurements(landmarks);
                
                // ì£¼ìš” ëœë“œë§ˆí¬ ê°•ì¡°
                highlightKeyLandmarks(landmarks);
            }
            
            ctx.restore();
        }
        
        // ì–¼êµ´ ë©”ì‹œ ê·¸ë¦¬ê¸°
        function drawFaceMesh(landmarks) {
            // ì—°ê²°ì„  ê·¸ë¦¬ê¸°
            FACEMESH_TESSELATION.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                ctx.beginPath();
                ctx.moveTo(startPoint.x * canvas.width, startPoint.y * canvas.height);
                ctx.lineTo(endPoint.x * canvas.width, endPoint.y * canvas.height);
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }
        
        // ì£¼ìš” ëœë“œë§ˆí¬ ê°•ì¡°
        function highlightKeyLandmarks(landmarks) {
            const keyPoints = [
                { idx: LANDMARKS.upperLip, color: '#ff4081', label: 'ìƒìˆœ' },
                { idx: LANDMARKS.lowerLip, color: '#ff4081', label: 'í•˜ìˆœ' },
                { idx: LANDMARKS.mouthLeft, color: '#2196f3', label: 'ì¢Œ' },
                { idx: LANDMARKS.mouthRight, color: '#2196f3', label: 'ìš°' },
                { idx: LANDMARKS.noseTip, color: '#4caf50', label: 'ì½”' },
                { idx: LANDMARKS.chinBottom, color: '#ff9800', label: 'í„±' }
            ];
            
            keyPoints.forEach(point => {
                const landmark = landmarks[point.idx];
                const x = landmark.x * canvas.width;
                const y = landmark.y * canvas.height;
                
                // ì  ê·¸ë¦¬ê¸°
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = point.color;
                ctx.fill();
                
                // ë¼ë²¨ ê·¸ë¦¬ê¸°
                ctx.fillStyle = point.color;
                ctx.font = '12px Arial';
                ctx.fillText(point.label, x + 8, y - 5);
            });
            
            // ì¤‘ì‹¬ì„  ê·¸ë¦¬ê¸°
            const noseTip = landmarks[LANDMARKS.noseTip];
            const chinBottom = landmarks[LANDMARKS.chinBottom];
            
            ctx.beginPath();
            ctx.moveTo(noseTip.x * canvas.width, noseTip.y * canvas.height);
            ctx.lineTo(chinBottom.x * canvas.width, chinBottom.y * canvas.height);
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // ì¸¡ì • ìˆ˜í–‰
        function performMeasurements(landmarks) {
            // 1. ì…ë²Œë¦¼ ê¸¸ì´ ê³„ì‚°
            const upperLip = landmarks[LANDMARKS.upperLip];
            const lowerLip = landmarks[LANDMARKS.lowerLip];
            const mouthOpenPx = Math.sqrt(
                Math.pow((upperLip.x - lowerLip.x) * canvas.width, 2) +
                Math.pow((upperLip.y - lowerLip.y) * canvas.height, 2)
            );
            const mouthOpenMm = (mouthOpenPx * PIXEL_TO_MM).toFixed(1);
            
            // 2. ì… ë„ˆë¹„ ê³„ì‚°
            const mouthLeft = landmarks[LANDMARKS.mouthLeft];
            const mouthRight = landmarks[LANDMARKS.mouthRight];
            const mouthWidthPx = Math.sqrt(
                Math.pow((mouthLeft.x - mouthRight.x) * canvas.width, 2) +
                Math.pow((mouthLeft.y - mouthRight.y) * canvas.height, 2)
            );
            const mouthWidthMm = (mouthWidthPx * PIXEL_TO_MM).toFixed(1);
            
            // 3. í¸ìœ„ ê³„ì‚° (ì–¼êµ´ ì¤‘ì‹¬ì„  ëŒ€ë¹„ ì… ì¤‘ì‹¬ì˜ í¸ì°¨)
            const noseTip = landmarks[LANDMARKS.noseTip];
            const chinBottom = landmarks[LANDMARKS.chinBottom];
            const faceCenterX = noseTip.x * canvas.width;
            const mouthCenterX = ((mouthLeft.x + mouthRight.x) / 2) * canvas.width;
			const deviationPxSigned = (mouthCenterX - faceCenterX);
			const deviationMmAbs = Math.abs(deviationPxSigned) * PIXEL_TO_MM;
			const deviationMm = deviationMmAbs.toFixed(1);
            
            // 4. ë³€ìœ„ ê³„ì‚° (í•˜ìˆœì˜ ì›€ì§ì„ ëˆ„ì )
            const currentLowerLipPos = {
                x: lowerLip.x * canvas.width,
                y: lowerLip.y * canvas.height
            };
            
            if (lastLowerLipPos) {
                const movementPx = Math.sqrt(
                    Math.pow(currentLowerLipPos.x - lastLowerLipPos.x, 2) +
                    Math.pow(currentLowerLipPos.y - lastLowerLipPos.y, 2)
                );
                totalDisplacement += movementPx * PIXEL_TO_MM;
            }
            lastLowerLipPos = currentLowerLipPos;
            
            // ê¶¤ì  í¬ì¸íŠ¸ ì¶”ê°€
            trajectoryPoints.push({
                x: currentLowerLipPos.x,
                y: currentLowerLipPos.y,
                timestamp: Date.now()
            });
            
            // ê¶¤ì  í¬ì¸íŠ¸ ì œí•œ (ìµœê·¼ 100ê°œë§Œ ìœ ì§€)
            if (trajectoryPoints.length > 100) {
                trajectoryPoints.shift();
            }
            
			// --- ê¶¤ì  ëˆ„ì  (ì§„ë‹¨ìš©; mm ì¢Œí‘œê³„) -------------------------
			const mouthOpenNow = parseFloat(mouthOpenMm);
			jawPath.push({ x: deviationPxSigned * PIXEL_TO_MM, y: mouthOpenNow });
			if (jawPath.length > 400) jawPath.shift();

			// --- ìµœëŒ€ì¹˜ ê°±ì‹ (íŒì •/ìº¡ì²˜ëŠ” 'ìµœëŒ€ ê·¼ì²˜ plateau'ì—ì„œ ì‹¤í–‰) ---
			if (mouthOpenNow > maxMouthOpen) {
			  maxMouthOpen = mouthOpenNow;
			  autoCaptureDone = false;
			  diagnosedThisCycle = false;
			}
			// plateau ê·¼ì²˜ë¼ê³  íŒë‹¨ë˜ëŠ” í”„ë ˆì„ì—ì„œ 1íšŒë§Œ íŒì •/ìº¡ì²˜
			const shouldAuto =
			  !autoCaptureDone &&
			  maxMouthOpen > 25 &&                          // ì†ŒìŒ ì œê±°ìš© ìµœì†Œì¹˜
			  mouthOpenNow >= maxMouthOpen - 0.2;           // plateau í­ (íŠœë‹ ê°€ëŠ¥)

			if (shouldAuto && !diagnosedThisCycle) {
			  const d = diagnoseJawPath(jawPath);           // ì¤‘ì‹¬ ë³µê·€+í¬ê¸°+ëª¨ì–‘ ì¢…í•©
			  lastDiagnosis = d;
			  applyDiagnosisToUI(d);                        // ë“±ê¸‰ ë°°ì§€/ì„¤ëª… ê°±ì‹ 

			  diagnosedThisCycle = true;
			  autoCaptureDone = true;                       // ìë™ ìº¡ì²˜ 1íšŒ ë³´í˜¸
			  queueMicrotask(() => captureFrame(landmarks));
			  document.getElementById('captureStatus').innerHTML =
				`<strong>âœ… ìë™ ìº¡ì²˜ & íŒì •</strong><br>${d.uiText} Â· ${d.explain}`;
			}
            
            // UI ì—…ë°ì´íŠ¸
            updateMeasurementUI(mouthOpenMm, mouthWidthMm, deviationMm);
            
            // ê¶¤ì  ê·¸ë¦¬ê¸°
            drawTrajectory();
        }
        
        // ì¸¡ì •ê°’ UI ì—…ë°ì´íŠ¸
        function updateMeasurementUI(mouthOpen, mouthWidth, deviation) {
            document.getElementById('mouthOpen').textContent = mouthOpen;
            document.getElementById('mouthWidth').textContent = mouthWidth;
            document.getElementById('deviation').textContent = deviation;
            document.getElementById('displacement').textContent = totalDisplacement.toFixed(1);
            document.getElementById('maxMouthOpen').textContent = maxMouthOpen.toFixed(1);
            
            // ì…ë²Œë¦¼ ìƒíƒœ íŒì • (ì •ìƒ: 0-20mm, ê²½ê³ : 20-35mm, ì´ìƒ: 35mm ì´ìƒ)
            const mouthOpenStatus = document.getElementById('mouthOpenStatus');
            if (parseFloat(mouthOpen) < 20) {
                mouthOpenStatus.className = 'status normal';
                mouthOpenStatus.textContent = 'ì •ìƒ';
            } else if (parseFloat(mouthOpen) < 35) {
                mouthOpenStatus.className = 'status warning';
                mouthOpenStatus.textContent = 'ì£¼ì˜';
            } else {
                mouthOpenStatus.className = 'status abnormal';
                mouthOpenStatus.textContent = 'ìµœëŒ€';
            }
            
            // í¸ìœ„ ìƒíƒœ íŒì • (ì •ìƒ: 0-2mm, ê²½ê³ : 2-4mm, ì´ìƒ: 4mm ì´ìƒ)
            const deviationStatus = document.getElementById('deviationStatus');
            if (parseFloat(deviation) < 2) {
                deviationStatus.className = 'status normal';
                deviationStatus.textContent = 'ì •ìƒ';
            } else if (parseFloat(deviation) < 4) {
                deviationStatus.className = 'status warning';
                deviationStatus.textContent = 'ê²½ë¯¸';
            } else {
                deviationStatus.className = 'status abnormal';
                deviationStatus.textContent = 'ì´ìƒ';
            }
        }
        
        // ê¶¤ì  ê·¸ë¦¬ê¸°
        function drawTrajectory() {
            trajectoryCtx.fillStyle = '#f5f5f5';
            trajectoryCtx.fillRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);
            
            // ê²©ì ê·¸ë¦¬ê¸°
            trajectoryCtx.strokeStyle = '#e0e0e0';
            trajectoryCtx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = (trajectoryCanvas.width / 10) * i;
                const y = (trajectoryCanvas.height / 10) * i;
                
                trajectoryCtx.beginPath();
                trajectoryCtx.moveTo(x, 0);
                trajectoryCtx.lineTo(x, trajectoryCanvas.height);
                trajectoryCtx.stroke();
                
                trajectoryCtx.beginPath();
                trajectoryCtx.moveTo(0, y);
                trajectoryCtx.lineTo(trajectoryCanvas.width, y);
                trajectoryCtx.stroke();
            }
            
            if (trajectoryPoints.length > 1) {
                // ê¶¤ì  ì„  ê·¸ë¦¬ê¸°
                trajectoryCtx.beginPath();
                trajectoryCtx.strokeStyle = '#e91e63';
                trajectoryCtx.lineWidth = 2;
                
                const scaleX = trajectoryCanvas.width / canvas.width;
                const scaleY = trajectoryCanvas.height / canvas.height;
                
                trajectoryPoints.forEach((point, index) => {
                    const x = point.x * scaleX;
                    const y = point.y * scaleY;
                    
                    if (index === 0) {
                        trajectoryCtx.moveTo(x, y);
                    } else {
                        trajectoryCtx.lineTo(x, y);
                    }
                });
                
                trajectoryCtx.stroke();
                
                // í˜„ì¬ ìœ„ì¹˜ í‘œì‹œ
                const lastPoint = trajectoryPoints[trajectoryPoints.length - 1];
                trajectoryCtx.beginPath();
                trajectoryCtx.arc(
                    lastPoint.x * scaleX,
                    lastPoint.y * scaleY,
                    5, 0, 2 * Math.PI
                );
                trajectoryCtx.fillStyle = '#e91e63';
                trajectoryCtx.fill();
            }
            
            // ì œëª©
            trajectoryCtx.fillStyle = '#333';
            trajectoryCtx.font = 'bold 14px Arial';
            trajectoryCtx.fillText('í•˜ìˆœ ì›€ì§ì„ ê¶¤ì ', 10, 20);
        }
		// ì „ì—­ì— ì¬ì‚¬ìš© ìº”ë²„ìŠ¤/í”Œë˜ê·¸
		let captureCanvas, captureCtx;
		let isCapturing = false;

		function ensureCaptureCanvas() {
		  if (!captureCanvas) {
			captureCanvas = document.createElement('canvas');
			captureCtx = captureCanvas.getContext('2d');
		  }
		  captureCanvas.width = canvas.width;
		  captureCanvas.height = canvas.height;
		}

		function canvasToBlobAsync(cv, type = 'image/png', quality) {
		  return new Promise((resolve, reject) => {
			cv.toBlob(blob => blob ? resolve(blob) : reject(new Error('toBlob failed')), type, quality);
		  });
		}
		// landmarksë¥¼ ì¸ìë¡œ ë°›ë„ë¡ ìˆ˜ì • + ë¹„ë™ê¸° ì²˜ë¦¬
		async function captureFrame(landmarks) {
		  if (isCapturing) return;
		  isCapturing = true;
		  try {
			ensureCaptureCanvas();

			// 1) í˜„ì¬ í”„ë ˆì„ì„ ì¦‰ì‹œ í•©ì„±(ê°€ë³ê³  ë¹ ë¦„)
			captureCtx.drawImage(video, 0, 0);
			captureCtx.drawImage(canvas, 0, 0);

			// 2) (ì˜µì…˜) ê¶¤ì /ê°€ì´ë“œë¼ì¸/í…ìŠ¤íŠ¸: ê¼­ í•„ìš”í•œ ê²ƒë§Œ, ê°„ë‹¨íˆ
			// ê¶¤ì 
			captureCtx.beginPath();
			captureCtx.lineWidth = 2;
			captureCtx.strokeStyle = '#e91e63';
			trajectoryPoints.forEach((p, i) => i ? captureCtx.lineTo(p.x, p.y) : captureCtx.moveTo(p.x, p.y));
			captureCtx.stroke();

			// ìˆ˜ì§ì„  (<= ì—¬ê¸°ì„œ landmarksëŠ” ë°˜ë“œì‹œ ì¸ìë¡œ ë°›ì€ ê²ƒì„ ì‚¬ìš©)
			const nose = landmarks[LANDMARKS.noseTip];
			const chin = landmarks[LANDMARKS.chinBottom];
			captureCtx.beginPath();
			captureCtx.setLineDash([5, 5]);
			captureCtx.moveTo(nose.x * canvas.width, nose.y * canvas.height);
			captureCtx.lineTo(chin.x * canvas.width, chin.y * canvas.height);
			captureCtx.strokeStyle = 'rgba(255,255,0,0.5)';
			captureCtx.stroke();
			captureCtx.setLineDash([]);

			// í…ìŠ¤íŠ¸
			captureCtx.fillStyle = '#000';
			captureCtx.font = '16px Arial';
			captureCtx.fillText(`ìµœëŒ€ ì…ë²Œë¦¼: ${maxMouthOpen.toFixed(1)}mm`, 20, 30);

			// 3) ì¸ì½”ë”©ì€ ë¹„ë™ê¸°ë¡œ(ë©”ì¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ì œê±°)
			//    PNGë³´ë‹¤ ë¹ ë¥¸ JPEG/WebPë„ ê³ ë ¤ ê°€ëŠ¥
			const blob = await canvasToBlobAsync(captureCanvas, 'image/jpeg', 0.92);
			const url = URL.createObjectURL(blob);


			capturedFrames.push({
			  imageUrl: url,
			  blob,
			  measurements: {
				 mouthOpen: maxMouthOpen.toFixed(1),
				 mouthWidth: document.getElementById('mouthWidth').textContent,
				 deviation: document.getElementById('deviation').textContent,
				 displacement: totalDisplacement.toFixed(1),
				 timestamp: new Date().toISOString()
			  }
			});
			// í”Œë˜ì‹œ íš¨ê³¼ëŠ” ê°€ë³ê²Œ ìœ ì§€
			ctx.fillStyle = 'rgba(255,255,255,0.35)';
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			setTimeout(() => ctx.clearRect(0, 0, canvas.width, canvas.height), 80);
		  } catch (e) {
			console.error('ìº¡ì²˜ ì‹¤íŒ¨:', e);
		  } finally {
			isCapturing = false;
		  }
		}
        
        // MediaPipe FACEMESH_TESSELATION ì—°ê²° ì •ì˜ (ê°„ì†Œí™” ë²„ì „)
        const FACEMESH_TESSELATION = [
            [127, 34], [34, 139], [139, 127], [11, 0], [0, 269], [269, 11],
            [270, 267], [267, 271], [271, 270], [272, 269], [269, 270], [270, 272],
            [46, 53], [53, 52], [52, 46], [65, 55], [55, 70], [70, 65],
            [63, 105], [105, 66], [66, 63], [107, 55], [55, 65], [65, 107],
            [109, 10], [10, 151], [151, 109], [337, 299], [299, 333], [333, 337],
            [298, 301], [301, 368], [368, 298], [301, 322], [322, 327], [327, 301],
            [17, 314], [314, 18], [18, 17], [316, 403], [403, 320], [320, 316],
            [307, 375], [375, 308], [308, 307], [324, 318], [318, 402], [402, 324],
            [35, 31], [31, 228], [228, 35], [229, 233], [233, 244], [244, 229],
            [245, 122], [122, 6], [6, 245], [202, 214], [214, 234], [234, 202],
            [124, 35], [35, 143], [143, 124], [225, 224], [224, 239], [239, 225],
            [235, 214], [214, 218], [218, 235], [237, 241], [241, 242], [242, 237],
            [132, 49], [49, 220], [220, 132], [305, 289], [289, 290], [290, 305],
            [349, 350], [350, 451], [451, 349], [452, 453], [453, 464], [464, 452],
            [234, 235], [235, 237], [237, 234], [93, 132], [132, 134], [134, 93],
            [77, 90], [90, 76], [76, 77], [62, 96], [96, 89], [89, 62],
            [164, 165], [165, 167], [167, 164], [87, 88], [88, 178], [178, 87],
            [95, 88], [88, 89], [89, 95], [78, 95], [95, 96], [96, 78],
            [46, 53], [53, 63], [63, 46], [52, 53], [53, 65], [65, 52],
            [220, 305], [305, 134], [134, 220], [289, 392], [392, 290], [290, 289],
            [276, 283], [283, 282], [282, 276], [293, 300], [300, 383], [383, 293],
            [328, 327], [327, 322], [322, 328], [454, 356], [356, 389], [389, 454],
            [251, 284], [284, 298], [298, 251], [362, 398], [398, 365], [365, 362],
            [330, 346], [346, 280], [280, 330], [404, 320], [320, 403], [403, 404],
            [275, 321], [321, 405], [405, 275], [373, 390], [390, 249], [249, 373],
            [285, 295], [295, 352], [352, 285], [376, 433], [433, 397], [397, 376],
            [288, 435], [435, 410], [410, 288], [384, 386], [386, 385], [385, 384],
            [96, 62], [62, 70], [70, 96], [53, 46], [46, 70], [70, 53],
            [55, 107], [107, 52], [52, 55], [65, 52], [52, 107], [107, 65]
        ];
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        startBtn.addEventListener('click', () => {
            if (!faceMesh) {
                initializeFaceMesh();
            }
            startCamera();
        });

		function diagnoseJawPath(points) {
		  // ìµœëŒ€ ê°œêµ¬ í”„ë ˆì„ ì°¾ê¸°
		  let tMax = 0;
		  for (let i = 1; i < points.length; i++) if (points[i].y > points[tMax].y) tMax = i;

		  const xAtMax = points[tMax].x;
		  const maxAbsDev = points.reduce((m,p)=>Math.max(m, Math.abs(p.x)), 0);

		  // â¶ ì¤‘ì‹¬ì„  ë³µê·€ ì—¬ë¶€: ìµœëŒ€ ì‹œì ì˜ ë‚¨ì€ ì¹˜ìš°ì¹¨
		  const RETURNS_CENTER_THRESHOLD = 1.5; // mm (í—ˆìš© ì˜¤ì°¨)
		  const returnsCenter = Math.abs(xAtMax) < RETURNS_CENTER_THRESHOLD;

		  // â· ê¶¤ì  ëª¨ì–‘ íŒë³„
		  //  - Sì: ê³¡ë¥ (2ì°¨ì°¨ë¶„) ë¶€í˜¸ê°€ ë°”ë€œ(=êµ½í˜ ë°©í–¥ì´ ë°”ë€œ)
		  //  - C/ì§ì„ : ê³¡ë¥  ë¶€í˜¸ ì¼ì • or ë§¤ìš° ì‘ìŒ
		  const shape = inferPathShape(points);

		  // â¸ í•œìª½ ì¹˜ìš°ì¹¨(ë¶€í˜¸ ì¼ê´€ì„±) & ì¤‘ì•™ êµì°¨ íšŸìˆ˜
		  const zeroCrossings = countZeroCrossings(points.map(p => p.x));
		  const sameSideRatio = sameSideConsistency(points.map(p => p.x));

		  // â¹ í¬ê¸° ê¸°ì¤€
		  const isMildDeviationRange = maxAbsDev >= 2 && maxAbsDev < 4;
		  const isDeflectionRange = maxAbsDev >= 4;

		  // âº ìµœì¢… ê·œì¹™
		  let label = 'Uncertain', severity = 'ê²€í†  í•„ìš”', reason = [];
		  if (returnsCenter && isMildDeviationRange && (shape === 'S' || zeroCrossings >= 1)) {
			label = 'Deviation';
			severity = 'ê²½ë¯¸';
			reason.push('ìµœëŒ€ ê°œêµ¬ ì‹œ ì¤‘ì‹¬ ë³µê·€', `ìµœëŒ€ í¸ìœ„ ${maxAbsDev.toFixed(1)}mm`, `ê¶¤ì  ${shape==='S'?'Sìí˜•':'ì¤‘ì•™ êµì°¨'}`);
		  } else if (!returnsCenter && isDeflectionRange && zeroCrossings === 0 && sameSideRatio > 0.9 && shape !== 'S') {
			label = 'Deflection';
			severity = 'ì˜ì‹¬ ë†’ìŒ';
			reason.push('ìµœëŒ€ ê°œêµ¬ ì‹œ ì¤‘ì‹¬ ë³µê·€ ì—†ìŒ', `ìµœëŒ€ í¸ìœ„ ${maxAbsDev.toFixed(1)}mm`, `ê¶¤ì  ${shape}`, 'í•œìª½ ì¹˜ìš°ì¹¨ ì¼ê´€');
		  } else {
			// ê²½ê³„ ìƒí™© ì²˜ë¦¬(ì˜ˆ: 2mm ë¯¸ë§Œ, 2â€“4mmì¸ë° Sí˜• ì•„ë‹˜ ë“±)
			if (maxAbsDev < 2) {
			  label = 'ì •ìƒ ë²”ìœ„';
			  severity = 'ì •ìƒ';
			  reason.push(`ìµœëŒ€ í¸ìœ„ ${maxAbsDev.toFixed(1)}mm (<2mm)`);
			} else if (isMildDeviationRange) {
			  label = returnsCenter ? 'Deviation(ê°€ëŠ¥)' : 'ë¶ˆí™•ì‹¤';
			  severity = returnsCenter ? 'ê²½ë¯¸' : 'ê²€í†  í•„ìš”';
			  reason.push(`ìµœëŒ€ í¸ìœ„ ${maxAbsDev.toFixed(1)}mm`, returnsCenter?'ì¤‘ì‹¬ ë³µê·€':'ë³µê·€ ë¶ˆì¶©ë¶„', `ê¶¤ì  ${shape}`);
			} else if (isDeflectionRange) {
			  label = 'Deflection(ê°€ëŠ¥)';
			  severity = 'ì˜ì‹¬';
			  reason.push(`ìµœëŒ€ í¸ìœ„ ${maxAbsDev.toFixed(1)}mm`, returnsCenter?'ë³µê·€ ìˆìœ¼ë‚˜ 4mm ì´ìƒ':'ë³µê·€ ì—†ìŒ', `ê¶¤ì  ${shape}`);
			}
		  }

		  // (ì„ íƒ) í†µì¦ ì²´í¬ ì‹œ ê°€ì¤‘
		  const pain = document.getElementById('painCheck')?.checked;
		  let uiText = label;
		  if (label.startsWith('Deflection') && pain) {
			uiText += ' Â· í†µì¦ â†’ ì¹˜ë£Œ ê¶Œê³ ';
			reason.push('í†µì¦ ë³´ê³ : ì¹˜ë£Œ í•„ìš”ì„± ë†’ìŒ');
		  }

		  return {
			label, severity, uiText,
			explain: reason.join(' Â· '),
			metrics: { maxAbsDev: +maxAbsDev.toFixed(1), returnsCenter, shape, zeroCrossings, sameSideRatio }
		  };
		}

		function countZeroCrossings(arr) {
		  let c = 0; for (let i=1;i<arr.length;i++) if (arr[i-1]===0) continue; else if (Math.sign(arr[i-1])!==Math.sign(arr[i]) && arr[i]!==0) c++;
		  return c;
		}

		function sameSideConsistency(arr) {
		  const firstSign = Math.sign(arr.find(v=>v!==0) ?? 0);
		  if (firstSign === 0) return 0; // ë°ì´í„° ë¶€ì¡±
		  const same = arr.filter(v => Math.sign(v) === firstSign).length;
		  return same / arr.length; // 0~1
		}

		// y(ì…ë²Œë¦¼) ì¦ê°€ ìˆœìœ¼ë¡œ ì •ë ¬í•´ x(y) ê³¡ë¥ ì„ ê°„ë‹¨ ì¶”ì •
		function inferPathShape(points) {
		  const pts = [...points].sort((a,b)=>a.y-b.y);
		  if (pts.length < 7) return 'ë¶ˆëª…í™•';

		  // 2ì°¨ ì°¨ë¶„ì˜ ë¶€í˜¸ ë³€í™”ë¥¼ ì²´í¬(ë…¸ì´ì¦ˆ ì™„í™”ìš© ì´ë™í‰ê·  í¬í•¨)
		  const smoothed = movingAverage(pts.map(p=>p.x), 3);
		  const second = [];
		  for (let i=2;i<smoothed.length;i++) second.push(smoothed[i]-2*smoothed[i-1]+smoothed[i-2]);

		  let pos=false, neg=false;
		  for (const v of second) {
			if (v > 0.02) pos = true;      // ì„ê³„ê°’ì€ mm ë‹¨ìœ„ ê¸°ì¤€ìœ¼ë¡œ ì•½ê°„ ì—¬ìœ 
			if (v < -0.02) neg = true;
		  }
		  if (pos && neg) return 'S';
		  const straightness = second.reduce((s,v)=>s+Math.abs(v),0);
		  return straightness < 0.2 ? 'ì§ì„ ' : 'Cì';
		}

		function movingAverage(arr, w=3) {
		  const out=[]; for (let i=0;i<arr.length;i++){ let s=0,c=0; for(let k=-Math.floor(w/2);k<=Math.floor(w/2);k++){ const j=i+k; if(j>=0 && j<arr.length){ s+=arr[j]; c++; } } out.push(s/c); }
		  return out;
		}
		
        function applyDiagnosisToUI(d) {
		  const deviationStatus = document.getElementById('deviationStatus');
		  if (!deviationStatus) return;

		  // ìƒ‰ìƒ(ì‹¬ê°ë„) ê²°ì •
		  if (d.label.startsWith('Deflection')) {
			deviationStatus.className = 'status abnormal';
		  } else if (d.label.startsWith('Deviation')) {
			deviationStatus.className = 'status warning';
		  } else {
			deviationStatus.className = 'status normal';
		  }
		  deviationStatus.textContent = d.uiText;

		  // ì•„ë˜ í•œ ì¤„ ì„¤ëª…(ì—†ìœ¼ë©´ ì¶”ê°€)
		  let diagLine = document.getElementById('diagnosisText');
		  if (!diagLine) {
			const container = deviationStatus.parentElement; // ì¸¡ì •ê°’ ë¼ì¸
			diagLine = document.createElement('div');
			diagLine.id = 'diagnosisText';
			diagLine.style.fontSize = '12px';
			diagLine.style.opacity = '0.8';
			container.appendChild(diagLine);
		  }
		  diagLine.textContent = d.explain;
		}

        stopBtn.addEventListener('click', stopCamera);
        resetBtn.addEventListener('click', resetMeasurements);
        captureBtn.addEventListener('click', () => {
            captureFrame();
            document.getElementById('captureStatus').innerHTML = 
                `<strong>ğŸ“¸ ìˆ˜ë™ ìº¡ì²˜ ì™„ë£Œ!</strong><br>ì‹œê°„: ${new Date().toLocaleString('ko-KR')}`;
        });
		document.getElementById('downloadBtn').addEventListener('click', () => {
		  if (capturedFrames.length === 0) return alert('ì €ì¥ëœ ìº¡ì²˜ ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
		  const latest = capturedFrames[capturedFrames.length - 1];
		  const link = document.createElement('a');
		  link.href = latest.imageUrl;
		  link.download = `capture_${Date.now()}.jpg`; // jpegê°€ pngë³´ë‹¤ ë³´í†µ ë¹ ë¦„
		  link.click();
		});

		// í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        window.addEventListener('load', () => {
            // ì»´í¬ë„ŒíŠ¸ì˜ ì‹¤ì œ ì½˜í…ì¸  ë†’ì´ë¥¼ ê³„ì‚°í•´ì„œ Streamlitì— ì•Œë¦½ë‹ˆë‹¤. ğŸ¤
            Streamlit.setFrameHeight(document.body.scrollHeight); 

            resetMeasurements();
            console.log('ì–¼êµ´ ì¸¡ì • ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ');
        });
        
        // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ì¹´ë©”ë¼ ì •ë¦¬
        window.addEventListener('beforeunload', () => {
            stopCamera();
        });
		
		// 0911

		const sendToStreamlitBtn = document.getElementById('sendToStreamlitBtn');

		// ì´ í•¨ìˆ˜ëŠ” ìœ íš¨í•œ ì¸¡ì •ì´ ì™„ë£Œë˜ì—ˆì„ ë•Œ ì œì¶œ ë²„íŠ¼ì„ í™œì„±í™”í•˜ê¸° ìœ„í•´ í˜¸ì¶œë©ë‹ˆë‹¤.
		function checkMeasurementAndEnableSubmit() {
			if (maxMouthOpen > 20 && autoCaptureDone) { // ìœ íš¨í•œ ìë™ ìº¡ì²˜ ì´í›„ì—ë§Œ í™œì„±í™”
				sendToStreamlitBtn.disabled = false;
			}
		}

		// ì´ í•¨ìˆ˜ë¥¼ ì£¼ê¸°ì ìœ¼ë¡œ í˜¸ì¶œí•˜ì—¬ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
		setInterval(checkMeasurementAndEnableSubmit, 1000);

		// ìƒˆë¡œ ë§Œë“  ë²„íŠ¼ì— í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
		sendToStreamlitBtn.addEventListener('click', () => {
			// íŒŒì´ì¬ìœ¼ë¡œ ë‹¤ì‹œ ë³´ë‚¼ ë°ì´í„° ê°ì²´ë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.
			const finalData = {
				maxOpening: maxMouthOpen.toFixed(1),
				deviation: document.getElementById('deviation').textContent,
				diagnosisLabel: lastDiagnosis ? lastDiagnosis.label : "N/A",
				// í•„ìš”í•œ ë‹¤ë¥¸ ê°’ë“¤ë„ ì—¬ê¸°ì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
			};

			// ì´ í•¨ìˆ˜ê°€ ë°”ë¡œ ë°ì´í„°ë¥¼ Streamlit ìŠ¤í¬ë¦½íŠ¸ë¡œ ë‹¤ì‹œ ë³´ë‚´ì£¼ëŠ” í•µì‹¬ í•¨ìˆ˜ì…ë‹ˆë‹¤!
			Streamlit.setComponentValue(finalData);
		});
		
    </script>
</body>
</html>