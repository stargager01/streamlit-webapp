<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TMJ Movement Analyzer - ÌÑ±Í¥ÄÏ†à ÏõÄÏßÅÏûÑ Î∂ÑÏÑùÍ∏∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            max-width: 1400px;
            width: 100%;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 14px;
        }
        
        .main-content {
            display: flex;
            gap: 30px;
            padding: 30px;
        }
        
        .video-section {
            flex: 1.5;
            position: relative;
        }
        
        .video-container {
            position: relative;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        #videoElement {
            width: 100%;
            height: auto;
            display: block;
            transform: scaleX(-1);
        }
        
        #canvasElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
        
        .controls-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .info-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }
        
        .info-panel h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #dee2e6;
        }
        
        .metric:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            color: #6c757d;
            font-size: 14px;
            font-weight: 500;
        }
        
        .metric-value {
            font-size: 18px;
            font-weight: 600;
            color: #212529;
        }
        
        .metric-value.highlight {
            color: #667eea;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        #calibrateBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        #startBtn {
            background: linear-gradient(135deg, #42e695 0%, #3bb2b8 100%);
            color: white;
        }
        
        #stopBtn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        #resetBtn {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: white;
        }
        
        .result-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 20px;
            color: white;
            display: none;
        }
        
        .result-panel.show {
            display: block;
            animation: slideIn 0.5s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .result-title {
            font-size: 18px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .result-value {
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            margin: 10px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        
        .pattern-normal {
            color: #42e695;
        }
        
        .pattern-deviation {
            color: #feca57;
        }
        
        .pattern-deflection {
            color: #ff6b6b;
        }
        
        .status {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            font-size: 14px;
        }
        
        .calibration-hint {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #ffc107;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #6c757d;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            background: currentColor;
            mask-size: contain;
            mask-repeat: no-repeat;
            mask-position: center;
        }
        
        .icon-ruler {
            mask-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="3" y2="18"></line><line x1="21" y1="6" x2="21" y2="18"></line></svg>');
        }
        
        .icon-chart {
            mask-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>');
        }
        
        .icon-target {
            mask-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>');
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü¶∑ TMJ Movement Analyzer</h1>
            <p>MediaPipe Face MeshÎ•º Ïù¥Ïö©Ìïú ÌÑ±Í¥ÄÏ†à ÏõÄÏßÅÏûÑ Ìå®ÌÑ¥ Î∂ÑÏÑù</p>
        </div>
        
        <div class="main-content">
            <div class="video-section">
                <div class="video-container">
                    <video id="videoElement" autoplay playsinline></video>
                    <canvas id="canvasElement"></canvas>
                </div>
                <div class="status" id="statusText">Î™®Îç∏ Î°úÎî© Ï§ë...</div>
            </div>
            
            <div class="controls-section">
                <div class="calibration-hint">
                    <strong>üìè Ï∏°Ï†ï Ï†Ñ ÌïÑÏàò!</strong><br>
                    Ïã†Ïö©Ïπ¥ÎìúÎ•º Ïù¥ÎßàÏóê ÎåÄÍ≥† 'Î≥¥Ï†ï' Î≤ÑÌäºÏùÑ ÎàåÎü¨ Ïä§ÏºÄÏùºÏùÑ ÏÑ§Ï†ïÌïòÏÑ∏Ïöî.
                </div>
                
                <div class="info-panel">
                    <h3><span class="icon icon-ruler"></span>Ïã§ÏãúÍ∞Ñ Ï∏°Ï†ïÍ∞í</h3>
                    <div class="metric">
                        <span class="metric-label">ÏµúÎåÄ Í∞úÍµ¨Îüâ</span>
                        <span class="metric-value highlight" id="maxOpening">0.0 mm</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">ÌòÑÏû¨ ÌÑ± Ìé∏Ïù¥</span>
                        <span class="metric-value" id="currentDeviation">Ï§ëÏïô 0.0 mm</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">ÏñºÍµ¥ Í∏∞Ïö∏Í∏∞</span>
                        <span class="metric-value" id="headTilt">0.0¬∞</span>
                    </div>
                </div>
                
                <div class="info-panel">
                    <h3><span class="icon icon-chart"></span>Ï∏°Ï†ï ÏÉÅÌÉú</h3>
                    <div class="metric">
                        <span class="metric-label">Î≥¥Ï†ï ÏÉÅÌÉú</span>
                        <span class="metric-value" id="calibrationStatus">ÎØ∏ÏôÑÎ£å ‚ùå</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Ï∏°Ï†ï ÏÉÅÌÉú</span>
                        <span class="metric-value" id="measurementStatus">ÎåÄÍ∏∞ Ï§ë</span>
                    </div>
                </div>
                
                <div class="result-panel" id="resultPanel">
                    <h3 class="result-title">üìä Î∂ÑÏÑù Í≤∞Í≥º</h3>
                    <div class="result-value" id="patternResult">-</div>
                    <div class="metric">
                        <span class="metric-label">ÏµúÎåÄ Ìé∏Ïù¥</span>
                        <span class="metric-value" id="finalMaxDev">-</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">ÏµúÏ¢Ö Ìé∏Ïù¥</span>
                        <span class="metric-value" id="finalEndDev">-</span>
                    </div>
                </div>
                
                <div class="button-group">
                    <button id="calibrateBtn">üìè Î≥¥Ï†ï</button>
                    <button id="startBtn" disabled>‚ñ∂ Ï∏°Ï†ï ÏãúÏûë</button>
                </div>
                <div class="button-group">
                    <button id="stopBtn" disabled>‚è∏ Ï∏°Ï†ï Ï§ëÏßÄ</button>
                    <button id="resetBtn">üîÑ Î¶¨ÏÖã</button>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <script>
        // Global variables
        let video, canvas, ctx;
        let faceMesh;
        let camera;
        let isCalibrated = false;
        let isMeasuring = false;
        let pixelsPerMM = 2.5; // Default value
        let trajectory = [];
        let maxOpeningValue = 0;
        let maxDeviationValue = 0;
        let maxDeviationDirection = 'Center';
        let finalDeviationValue = 0;
        let currentLandmarks = null;
        
        // Landmark indices for MediaPipe Face Mesh
        const LANDMARKS = {
            GLABELLA: 9,
            NOSE_BRIDGE: 6,
            UPPER_LIP_INNER: 13,
            LOWER_LIP_INNER: 14,
            CHIN_TIP: 18,
            LEFT_EYE_OUTER: 33,
            RIGHT_EYE_OUTER: 263,
            NOSE_TIP: 1,
            LEFT_CHEEK: 205,
            RIGHT_CHEEK: 425
        };
        
        // Initialize
        async function init() {
            video = document.getElementById('videoElement');
            canvas = document.getElementById('canvasElement');
            ctx = canvas.getContext('2d');
            
            // Initialize MediaPipe Face Mesh
            initializeFaceMesh();
            
            // Setup camera
            setupCamera();
        }
        
        // Initialize MediaPipe Face Mesh
        function initializeFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onResults);
            
            document.getElementById('statusText').textContent = 'Î™®Îç∏ Î°úÎî© ÏôÑÎ£å';
        }
        
        // Setup camera
        function setupCamera() {
            camera = new Camera(video, {
                onFrame: async () => {
                    if (faceMesh) {
                        await faceMesh.send({image: video});
                    }
                },
                width: 1280,
                height: 720
            });
            
            camera.start();
            
            video.addEventListener('loadeddata', () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                document.getElementById('statusText').textContent = 'Ï§ÄÎπÑ ÏôÑÎ£å';
            });
        }
        
        // Process Face Mesh results
        function onResults(results) {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Flip canvas horizontally for mirror effect
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                currentLandmarks = results.multiFaceLandmarks[0];
                
                // Convert normalized coordinates to pixel coordinates
                const landmarks = currentLandmarks.map(landmark => ({
                    x: landmark.x * canvas.width,
                    y: landmark.y * canvas.height,
                    z: landmark.z
                }));
                
                // Draw face mesh
                drawFaceMesh(landmarks);
                
                // Draw centerline
                drawCenterline(landmarks);
                
                // Calculate metrics
                calculateMetrics(landmarks);
                
                // Track trajectory if measuring
                if (isMeasuring) {
                    trackTrajectory(landmarks);
                }
                
                // Draw trajectory
                if (trajectory.length > 1) {
                    drawTrajectory();
                }
            }
            
            ctx.restore();
        }
        
        // Draw face mesh
        function drawFaceMesh(landmarks) {
            // Draw mesh points
            ctx.fillStyle = 'rgba(102, 126, 234, 0.5)';
            landmarks.forEach((landmark, idx) => {
                // Draw important landmarks
                if ([9, 6, 13, 14, 18, 33, 263, 1].includes(idx)) {
                    ctx.beginPath();
                    ctx.arc(landmark.x, landmark.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Draw lip line
            if (landmarks[13] && landmarks[14]) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(landmarks[13].x, landmarks[13].y);
                ctx.lineTo(landmarks[14].x, landmarks[14].y);
                ctx.stroke();
            }
        }
        
        // Draw centerline
        function drawCenterline(landmarks) {
            const glabella = landmarks[9];  // Forehead center
            const noseTip = landmarks[1];    // Nose tip
            
            if (glabella && noseTip) {
                ctx.strokeStyle = '#42e695';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                
                // Extend line beyond face
                const dx = noseTip.x - glabella.x;
                const dy = noseTip.y - glabella.y;
                const extension = 1.5;
                
                ctx.moveTo(glabella.x - dx * extension, glabella.y - dy * extension);
                ctx.lineTo(noseTip.x + dx * extension, noseTip.y + dy * extension);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // Calculate metrics
        function calculateMetrics(landmarks) {
            const upperLip = landmarks[13];
            const lowerLip = landmarks[14];
            const chinTip = landmarks[18];
            const glabella = landmarks[9];
            const noseTip = landmarks[1];
            const leftEye = landmarks[33];
            const rightEye = landmarks[263];
            
            if (upperLip && lowerLip && chinTip && glabella && noseTip) {
                // Calculate opening in pixels
                const openingPx = Math.sqrt(
                    Math.pow(upperLip.x - lowerLip.x, 2) + 
                    Math.pow(upperLip.y - lowerLip.y, 2)
                );
                const openingMM = openingPx / pixelsPerMM;
                
                // Calculate centerline
                const centerX = (glabella.x + noseTip.x) / 2;
                
                // Calculate deviation
                const deviationPx = chinTip.x - centerX;
                const deviationMM = Math.abs(deviationPx) / pixelsPerMM;
                const direction = deviationPx < 0 ? 'Rt' : deviationPx > 0 ? 'Lt' : 'Ï§ëÏïô';
                
                // Update max values if measuring
                if (isMeasuring) {
                    if (openingMM > maxOpeningValue) {
                        maxOpeningValue = openingMM;
                        // Record final deviation at max opening
                        finalDeviationValue = deviationMM;
                    }
                    
                    if (deviationMM > maxDeviationValue) {
                        maxDeviationValue = deviationMM;
                        maxDeviationDirection = deviationPx < 0 ? 'Right' : 'Left';
                    }
                }
                
                // Calculate head tilt
                let tilt = 0;
                if (leftEye && rightEye) {
                    const dx = rightEye.x - leftEye.x;
                    const dy = rightEye.y - leftEye.y;
                    tilt = Math.atan2(dy, dx) * (180 / Math.PI);
                }
                
                // Update UI
                if (isMeasuring) {
                    document.getElementById('maxOpening').textContent = `${maxOpeningValue.toFixed(1)} mm`;
                } else {
                    document.getElementById('maxOpening').textContent = `${openingMM.toFixed(1)} mm`;
                }
                document.getElementById('currentDeviation').textContent = `${direction} ${deviationMM.toFixed(1)} mm`;
                document.getElementById('headTilt').textContent = `${tilt.toFixed(1)}¬∞`;
            }
        }
        
        // Track trajectory
        function trackTrajectory(landmarks) {
            const chinTip = landmarks[18];
            if (chinTip) {
                trajectory.push({
                    x: chinTip.x,
                    y: chinTip.y,
                    timestamp: Date.now()
                });
            }
        }
        
        // Draw trajectory
        function drawTrajectory() {
            if (trajectory.length < 2) return;
            
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(trajectory[0].x, trajectory[0].y);
            
            for (let i = 1; i < trajectory.length; i++) {
                ctx.lineTo(trajectory[i].x, trajectory[i].y);
            }
            ctx.stroke();
            
            // Draw start point
            ctx.fillStyle = '#42e695';
            ctx.beginPath();
            ctx.arc(trajectory[0].x, trajectory[0].y, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw end point if stopped
            if (!isMeasuring && trajectory.length > 0) {
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(trajectory[trajectory.length - 1].x, trajectory[trajectory.length - 1].y, 5, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        // Calibration
        function calibrate() {
            // Simulated calibration with credit card (85.6mm width)
            const creditCardWidthMM = 85.6;
            // This would normally involve detecting the card in the image
            // For demonstration, we'll use a reasonable estimate
            const estimatedCardWidthPx = 240; // Approximate pixels for card at typical distance
            pixelsPerMM = estimatedCardWidthPx / creditCardWidthMM;
            
            isCalibrated = true;
            document.getElementById('calibrationStatus').textContent = 'ÏôÑÎ£å ‚úÖ';
            document.getElementById('calibrationStatus').style.color = '#42e695';
            document.getElementById('startBtn').disabled = false;
            
            alert(`Î≥¥Ï†ï ÏôÑÎ£å!\n1mm = ${pixelsPerMM.toFixed(2)} pixels`);
        }
        
        // Start measurement
        function startMeasurement() {
            if (!isCalibrated) {
                alert('Î®ºÏ†Ä Î≥¥Ï†ïÏùÑ ÏàòÌñâÌïòÏÑ∏Ïöî!');
                return;
            }
            
            isMeasuring = true;
            trajectory = [];
            maxOpeningValue = 0;
            maxDeviationValue = 0;
            finalDeviationValue = 0;
            
            document.getElementById('measurementStatus').textContent = 'Ï∏°Ï†ï Ï§ë...';
            document.getElementById('measurementStatus').style.color = '#42e695';
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('calibrateBtn').disabled = true;
            document.getElementById('resultPanel').classList.remove('show');
        }
        
        // Stop measurement
        function stopMeasurement() {
            if (!isMeasuring) return;
            
            isMeasuring = false;
            document.getElementById('measurementStatus').textContent = 'Ï∏°Ï†ï ÏôÑÎ£å';
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('calibrateBtn').disabled = false;
            
            // Analyze pattern
            analyzePattern();
            
            // Generate and log JSON data
            generateJSON();
			
			// ---- ÏûêÎèô Ïù¥ÎØ∏ÏßÄ Ï∫°Ï≥ê Ï∂îÍ∞Ä ----
			captureScreenshot();
	
        }
		
		// Ï∫°Ï≥ê Ìï®Ïàò
		function captureScreenshot() {
			const canvas = document.getElementById('canvasElement');
			const video = document.getElementById('videoElement');

			// ÏÉàÎ°úÏö¥ Ï∫îÎ≤ÑÏä§Ïóê ÎπÑÎîîÏò§ + Ïò§Î≤ÑÎ†àÏù¥ Ìï©ÏÑ±
			const exportCanvas = document.createElement('canvas');
			exportCanvas.width = canvas.width;
			exportCanvas.height = canvas.height;
			const exportCtx = exportCanvas.getContext('2d');

			// ÎπÑÎîîÏò§ ÌîÑÎ†àÏûÑ Í∑∏Î¶¨Í∏∞
			exportCtx.drawImage(video, 0, 0, exportCanvas.width, exportCanvas.height);
			// Ïò§Î≤ÑÎ†àÏù¥ (Ï∏°Ï†ïÏÑ†, Í∂§Ï†Å Îì±) Í∑∏Î¶¨Í∏∞
			exportCtx.drawImage(canvas, 0, 0);

			// ---- Ï∏°Ï†ï Ï†ïÎ≥¥ ÌÖçÏä§Ìä∏ Ï∂îÍ∞Ä ----
			const maxOpen = maxOpeningValue.toFixed(1);
			const finalDev = finalDeviationValue.toFixed(1);
			const pattern = document.getElementById('patternResult').textContent;

			exportCtx.fillStyle = "rgba(0,0,0,0.6)";   // Î∞òÌà¨Î™Ö Î∞∞Í≤Ω
			exportCtx.fillRect(20, 20, 400, 100);

			exportCtx.fillStyle = "white";
			exportCtx.font = "20px Arial";
			exportCtx.textBaseline = "top";
			exportCtx.fillText(`ÏµúÎåÄ Í∞úÍµ¨Îüâ: ${maxOpen} mm`, 30, 30);
			exportCtx.fillText(`ÏµúÏ¢Ö ÌÑ± Ìé∏Ïù¥: ${finalDev} mm`, 30, 60);
			exportCtx.fillText(`Î∂ÑÏÑù Í≤∞Í≥º: ${pattern}`, 30, 90);

			// ---- Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ----
			const dataURL = exportCanvas.toDataURL("image/png");

			// ÏûêÎèô Îã§Ïö¥Î°úÎìú
			const link = document.createElement('a');
			link.href = dataURL;
			link.download = `TMJ_${maxOpen}mm_${finalDev}mm_${pattern}.png`;
			link.click();
		}

		
        // Analyze movement pattern
        function analyzePattern() {
            const threshold = 2.0; // mm
            let pattern = 'Normal';
            let patternKo = 'Ï†ïÏÉÅ';
            
            if (maxDeviationValue >= threshold) {
                if (finalDeviationValue >= threshold) {
                    pattern = 'Deflection';
                    patternKo = 'Íµ¥Ï†à';
                } else {
                    pattern = 'Deviation';
                    patternKo = 'Ìé∏Ï∞®';
                }
            }
            
            // Show results
            const resultPanel = document.getElementById('resultPanel');
            resultPanel.classList.add('show');
            
            const patternResult = document.getElementById('patternResult');
            patternResult.textContent = `${patternKo} (${pattern})`;
            patternResult.className = 'result-value';
            
            if (pattern === 'Normal') {
                patternResult.classList.add('pattern-normal');
            } else if (pattern === 'Deviation') {
                patternResult.classList.add('pattern-deviation');
            } else {
                patternResult.classList.add('pattern-deflection');
            }
            
            document.getElementById('finalMaxDev').textContent = 
                `${maxDeviationDirection} ${maxDeviationValue.toFixed(1)} mm`;
            document.getElementById('finalEndDev').textContent = 
                `${finalDeviationValue.toFixed(1)} mm`;
        }
        
        // Generate JSON output
        function generateJSON() {
            const threshold = 2.0;
            let pattern = 'Normal';
            
            if (maxDeviationValue >= threshold) {
                pattern = finalDeviationValue >= threshold ? 'Deflection' : 'Deviation';
            }
            
            const jsonData = {
                timestamp: new Date().toISOString(),
                measurements: {
                    maxOpening_mm: parseFloat(maxOpeningValue.toFixed(1)),
                    jawMovementPattern: pattern,
                    maxDeviation_mm: parseFloat(maxDeviationValue.toFixed(1)),
                    maxDeviation_direction: maxDeviationDirection,
                    finalDeviation_mm: parseFloat(finalDeviationValue.toFixed(1))
                },
                calibration: {
                    pixelsPerMM: parseFloat(pixelsPerMM.toFixed(2))
                },
                trajectory: trajectory.map(point => ({
                    x: parseFloat(point.x.toFixed(1)),
                    y: parseFloat(point.y.toFixed(1))
                }))
            };
            
            console.log('Measurement Results:', jsonData);
        }
        
        // Reset
        function reset() {
            isMeasuring = false;
            isCalibrated = false;
            trajectory = [];
            maxOpeningValue = 0;
            maxDeviationValue = 0;
            finalDeviationValue = 0;
            pixelsPerMM = 1;
            
            document.getElementById('calibrationStatus').textContent = 'ÎØ∏ÏôÑÎ£å ‚ùå';
            document.getElementById('calibrationStatus').style.color = '#dc3545';
            document.getElementById('measurementStatus').textContent = 'ÎåÄÍ∏∞ Ï§ë';
            document.getElementById('measurementStatus').style.color = '#6c757d';
            document.getElementById('maxOpening').textContent = '0.0 mm';
            document.getElementById('currentDeviation').textContent = 'Ï§ëÏïô 0.0 mm';
            document.getElementById('headTilt').textContent = '0.0¬∞';
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('calibrateBtn').disabled = false;
            document.getElementById('resultPanel').classList.remove('show');
        }
        
        // Event listeners
        document.getElementById('calibrateBtn').addEventListener('click', calibrate);
        document.getElementById('startBtn').addEventListener('click', startMeasurement);
        document.getElementById('stopBtn').addEventListener('click', stopMeasurement);
        document.getElementById('resetBtn').addEventListener('click', reset);
        
        // Start application
        init();
    </script>
</body>
</html>