<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>턱 최대 개구량 측정 시스템 (개선된 립 마커)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); overflow: hidden; }
    #container { position: relative; width: 100vw; height: 100vh; }
    #videoCanvas, #threeCanvas, #lipMarkerCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    #videoCanvas { display: none; }
    #threeCanvas, #lipMarkerCanvas { pointer-events: none; }
    #webcam { position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    #webcam.inverted { filter: invert(1); }
    #faceGuide { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 300px; height: 400px; border: 3px dashed rgba(255,255,255,0.5); border-radius: 150px 150px 180px 180px / 200px 200px 180px 180px; pointer-events: none; display: flex; align-items: center; justify-content: center; z-index: 100; }
    #faceGuide.active { border-color: #00ff00; animation: pulse 1s infinite; }
    @keyframes pulse { 0%,100% {opacity:1;} 50% {opacity:.5;} }
    #guideText { color: #fff; text-align: center; font-size: 18px; background: rgba(0,0,0,.5); padding:10px; border-radius:10px; }
    .ui-panel { position: absolute; background: rgba(255,255,255,.95); border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,.15); transition: all .3s; }
    #statusPanel { top: 20px; left: 20px; max-width: 350px; }
    #metricsPanel { top: 20px; right: 20px; min-width: 280px; }
    #controlPanel { bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
    #resultsPanel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255,255,255,.98); padding: 30px; border-radius: 15px; box-shadow: 0 8px 30px rgba(0,0,0,.2); display: none; max-width: 500px; width: 90%; }
    h2 { color:#333; margin-bottom: 15px; font-size: 1.4em; }
    h3 { color:#555; margin-bottom: 10px; font-size: 1.1em; }
    .status-text { color:#666; line-height:1.5; margin-bottom:10px; }
    .metrics { display: grid; gap: 10px; }
    .metric-item { display:flex; justify-content:space-between; padding:8px; background: rgba(102,126,234,.1); border-radius:6px; }
    .metric-label { color:#555; font-weight:500; }
    .metric-value { color:#667eea; font-weight:bold; }
    button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:#fff; border:none; padding:12px 24px; border-radius:8px; font-size:16px; cursor:pointer; transition: transform .2s, box-shadow .2s; }
    button:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(102,126,234,.4); }
    button:disabled { opacity:.5; cursor:not-allowed; transform:none; }
    .phase-indicator { display:inline-block; padding:5px 12px; border-radius:20px; background:#f0f0f0; color:#666; font-size:12px; font-weight:bold; margin-bottom:10px; }
    .phase-calibration { background:#ffe4b5; color:#ff8c00; }
    .phase-tracking { background:#b5e7ff; color:#0080ff; }
    .phase-complete { background:#b5ffb5; color:#00b300; }
    #calibrationProgress { width:100%; height:6px; background:#e0e0e0; border-radius:3px; overflow:hidden; margin:10px 0; }
    #calibrationBar { height:100%; background: linear-gradient(90deg, #667eea, #764ba2); width:0%; transition: width .1s; }
    #loadingOverlay { position:absolute; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,.8); display:flex; flex-direction:column; justify-content:center; align-items:center; color:#fff; z-index:1000; }
    .loader { border:4px solid #f3f3f3; border-top:4px solid #667eea; border-radius:50%; width:50px; height:50px; animation: spin 1s linear infinite; margin-bottom:20px; }
    @keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }
    .instructions { background: rgba(255,255,224,.95); padding:10px; border-left:4px solid #ffa500; margin:10px 0; border-radius:4px; }
    .result-title { font-size:24px; color:#00a65a; font-weight:700; }
    .lip-status { background: rgba(0,170,255,.1); padding: 5px 10px; border-radius: 5px; margin-top: 5px; font-size: 12px; color: #0080ff; }
  </style>
</head>
<body>
  <div id="container">
    <video id="webcam" autoplay playsinline></video>
    <canvas id="videoCanvas"></canvas>
    <canvas id="threeCanvas"></canvas>
    <canvas id="lipMarkerCanvas"></canvas>

    <div id="loadingOverlay">
      <div class="loader"></div>
      <div>턱 추적 시스템 초기화 중...</div>
    </div>

    <div class="ui-panel" id="statusPanel">
      <h2>턱 최대 개구량 측정</h2>
      <div id="phaseIndicator" class="phase-indicator">대기중</div>
      <div id="statusText" class="status-text">카메라 접근 권한을 허용해주세요.</div>
      <div id="calibrationProgress" style="display:none;">
        <div id="calibrationBar"></div>
      </div>
      <div id="instructions" class="instructions" style="display:none;"></div>
      <div id="lipTracking" class="lip-status" style="display:none;">
        아랫입술 추적: <span id="lipTrackingStatus">대기</span>
      </div>
    </div>

    <div class="ui-panel" id="metricsPanel">
      <h3>실시간 측정값</h3>
      <div class="metrics">
        <div class="metric-item">
          <span class="metric-label">현재 개구량</span>
          <span class="metric-value" id="verticalDisp">0.00 mm</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">최대 개구량</span>
          <span class="metric-value" id="maxVerticalDisp">0.00 mm</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">얼굴 감지</span>
          <span class="metric-value" id="faceStatus">미감지</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">가이드 영역</span>
          <span class="metric-value" id="guideStatus">벗어남</span>
        </div>
      </div>
    </div>

    <div class="ui-panel" id="controlPanel">
      <button id="startBtn" onclick="startCalibration()">시작</button>
      <button id="resetBtn" onclick="resetSystem()" disabled>초기화</button>
      <button id="saveBtn" onclick="saveResults()" disabled>결과 저장</button>
      <button id="captureMaxBtn" onclick="manualCaptureMaxOpening()">최대개구 캡쳐</button>
      <button id="toggleLipMarker" onclick="toggleLipMarker()">립마커 표시/숨김</button>
      <button id="downloadImagesBtn" onclick="downloadAllImages()" style="display:none;">캡쳐 이미지 다운로드</button>
    </div>

    <div id="resultsPanel">
      <h2>측정 결과</h2>
      <div id="resultType" class="result-title"></div>
      <div class="metrics" style="margin-top: 20px;">
        <div class="metric-item">
          <span class="metric-label">최대 개구량</span>
          <span class="metric-value" id="finalMaxOpening">-</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">측정 시간</span>
          <span class="metric-value" id="measurementTime">-</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">캡쳐 이미지</span>
          <span class="metric-value" id="captureCount">-</span>
        </div>
      </div>
      <button onclick="closeResults()" style="margin-top:20px; width:100%;">확인</button>
    </div>

    <div id="faceGuide">
      <div id="guideText">얼굴을 여기에 맞춰주세요</div>
    </div>
  </div>

  <!-- External libs -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // ===== 전역 상태 =====
    let faceMesh, camera;
    let scene, renderer, threeCamera;
    let trajectoryLine, maxOpeningMarker;
    let lipMarkerCtx; // 립 마커 캔버스 컨텍스트

    let isCalibrated = false;
    let isTracking = false;
    let isFaceInGuide = false;
    let isJawTracking = false;
    let isTrackingComplete = false;
    let showLipMarker = true;

    let chinRestPosition = null;
    let calibrationSamples = [];

    let maxVerticalOpening = 0;
    let currentVerticalOpening = 0;
    let trajectoryPoints = [];
    let lastJawPosition = null;
    
    // 실시간 추적용 변수
    let currentLipPosition = null;
    let lipPositionHistory = [];

    // 가이드 경계 (화면 중심 기준 px)
    const GUIDE_BOUNDS = { x: {min: -150, max: 150}, y: {min: -200, max: 200} };

    // 파라미터
    const JAW_OPEN_THRESHOLD = 15;
    const PIXELS_TO_MM = 0.3;

    // 캡쳐 상태
    let capturedImages = [];
    let maxOpeningCaptured = false;

    // FaceMesh 인덱스 (아랫입술 관련 추가)
    const CHIN_INDEX = 152;
    const NOSE_TIP_INDEX = 1;
    const LEFT_MOUTH_INDEX = 61;
    const RIGHT_MOUTH_INDEX = 291;
    const LOWER_LIP_CENTER = 17; // 아랫입술 중앙
    const LOWER_LIP_LEFT = 84; // 아랫입술 왼쪽
    const LOWER_LIP_RIGHT = 314; // 아랫입술 오른쪽
    const LOWER_LIP_BOTTOM = 18; // 아랫입술 바닥

    // ===== 유틸 =====
    function updateStatus(msg){ document.getElementById('statusText').textContent = msg; }
    function setPhase(phase){
      const indicator = document.getElementById('phaseIndicator');
      indicator.className = 'phase-indicator';
      if(phase==='waiting'){ indicator.textContent='대기중'; }
      if(phase==='calibration'){ indicator.textContent='교정중'; indicator.classList.add('phase-calibration'); }
      if(phase==='tracking'){ indicator.textContent='추적중'; indicator.classList.add('phase-tracking'); }
      if(phase==='complete'){ indicator.textContent='완료'; indicator.classList.add('phase-complete'); }
    }
    function updateMetrics(verticalMM){
      const v = Math.max(0, verticalMM);
      document.getElementById('verticalDisp').textContent = v.toFixed(2)+ ' mm';
      const maxMM = maxVerticalOpening * PIXELS_TO_MM;
      document.getElementById('maxVerticalDisp').textContent = maxMM.toFixed(2) + ' mm';
    }

    function toggleLipMarker() {
      showLipMarker = !showLipMarker;
      if(!showLipMarker && lipMarkerCtx) {
        lipMarkerCtx.clearRect(0, 0, lipMarkerCtx.canvas.width, lipMarkerCtx.canvas.height);
      }
      document.getElementById('toggleLipMarker').textContent = showLipMarker ? '립마커 숨김' : '립마커 표시';
    }

    // ===== 립 마커 그리기 (실시간) =====
    function drawLipMarker() {
      if(!lipMarkerCtx || !currentLipPosition || !showLipMarker) return;
      
      const canvas = lipMarkerCtx.canvas;
      lipMarkerCtx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 미러링된 좌표 보정
      const mirroredX = canvas.width - currentLipPosition.x;
      
      // 1cm 직경 구 그리기
      const diameterPx = 10 / PIXELS_TO_MM; // 10mm를 픽셀로
      const radius = diameterPx / 2;
      
      lipMarkerCtx.beginPath();
      lipMarkerCtx.arc(mirroredX, currentLipPosition.y, radius, 0, Math.PI * 2);
      lipMarkerCtx.fillStyle = 'rgba(0, 170, 255, 0.35)';
      lipMarkerCtx.fill();
      lipMarkerCtx.lineWidth = 2;
      lipMarkerCtx.strokeStyle = 'rgba(0, 120, 220, 0.9)';
      lipMarkerCtx.stroke();
      
      // 중심점 표시
      lipMarkerCtx.beginPath();
      lipMarkerCtx.arc(mirroredX, currentLipPosition.y, 2, 0, Math.PI * 2);
      lipMarkerCtx.fillStyle = 'red';
      lipMarkerCtx.fill();
      
      // 추적 상태 표시
      document.getElementById('lipTracking').style.display = 'block';
      document.getElementById('lipTrackingStatus').textContent = '활성';
    }

    // ===== 캡쳐 =====
    function captureImage(label='capture'){
      const video = document.getElementById('webcam');
      if(!video.videoWidth){ return null; }
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth; 
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      
      // 비디오 프레임 복사 (미러링 해제)
      ctx.save(); 
      ctx.scale(-1,1); 
      ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height); 
      ctx.restore();
      
      // Three.js 오버레이 합성
      const threeCanvas = document.getElementById('threeCanvas');
      ctx.drawImage(threeCanvas, 0, 0, canvas.width, canvas.height);

      // 라벨 및 시간
      ctx.fillStyle = 'white';
      ctx.font = 'bold 20px Arial';
      ctx.fillText(`${label} - ${new Date().toLocaleTimeString()}`, 10, 30);

      // 아랫입술 구 표시 (캡쳐용)
      if((label === 'jaw_max_opening' || label === 'jaw_calibration_start') && currentLipPosition){
        const scaleX = canvas.width / window.innerWidth;
        const scaleY = canvas.height / window.innerHeight;
        
        // 캔버스 좌표로 변환 (미러링 해제된 상태)
        const lipX = currentLipPosition.x * scaleX;
        const lipY = currentLipPosition.y * scaleY;
        
        const diameterPx = 10 / PIXELS_TO_MM;
        const radius = (diameterPx / 2) * ((scaleX + scaleY) / 2);
        
        ctx.beginPath();
        ctx.arc(lipX, lipY, radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 170, 255, 0.35)';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(0, 120, 220, 0.9)';
        ctx.stroke();
        
        // 중심점
        ctx.beginPath();
        ctx.arc(lipX, lipY, 3, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
      }

      // 최대 개구량 텍스트
      if(label === 'jaw_max_opening'){
        const maxMM = (maxVerticalOpening * PIXELS_TO_MM).toFixed(2);
        const pad = 10;
        const boxW = 260, boxH = 40;
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fillRect(canvas.width - boxW - pad, pad, boxW, boxH);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 22px Arial';
        ctx.fillText(`최대 개구량: ${maxMM} mm`, canvas.width - boxW + 12, pad + 27);
      }

      const timestamp = new Date().toISOString();
      const data = canvas.toDataURL('image/png');
      capturedImages.push({ label, timestamp, data });
      
      if(label === 'jaw_calibration_start' || label === 'jaw_max_opening'){
        downloadImage(data, `jaw_${label}_${timestamp.replace(/[:.]/g,'-')}.png`);
      }
      showCaptureEffect();
      return data;
    }

    function showCaptureEffect(){
      const flash = document.createElement('div');
      flash.style.position='fixed'; flash.style.top='0'; flash.style.left='0';
      flash.style.width='100%'; flash.style.height='100%'; flash.style.background='white';
      flash.style.opacity='0.3'; flash.style.zIndex='9999'; flash.style.pointerEvents='none';
      document.body.appendChild(flash);
      setTimeout(()=>{ flash.style.transition='opacity .3s'; flash.style.opacity='0'; setTimeout(()=>flash.remove(),300); },100);
    }

    function downloadImage(dataUrl, filename){ 
      const a=document.createElement('a'); 
      a.href=dataUrl; 
      a.download=filename; 
      a.click(); 
    }

    function downloadAllImages(){
      if(capturedImages.length===0){ alert('캡쳐된 이미지가 없습니다.'); return; }
      capturedImages.forEach((img, idx)=>{ 
        setTimeout(()=> downloadImage(img.data, `jaw_${img.label}_${idx+1}.png`), idx*400); 
      });
      alert(`${capturedImages.length}장의 이미지를 다운로드합니다.`);
    }

    function manualCaptureMaxOpening(){ 
      captureImage('jaw_max_opening'); 
    }

    // ===== Three.js =====
    function initThreeJS(){
      scene = new THREE.Scene();
      const canvas = document.getElementById('threeCanvas');
      renderer = new THREE.WebGLRenderer({ canvas, alpha:true, antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      threeCamera = new THREE.OrthographicCamera(
        window.innerWidth / -2, window.innerWidth / 2,
        window.innerHeight / 2, window.innerHeight / -2, 1, 1000
      );
      threeCamera.position.z = 10;
      const ambient = new THREE.AmbientLight(0xffffff, .6); 
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, .4); 
      dir.position.set(0,1,1); 
      scene.add(dir);
      animate();
    }

    function animate(){ 
      requestAnimationFrame(animate); 
      renderer.render(scene, threeCamera); 
      drawLipMarker(); // 실시간 립 마커 그리기
    }

    function updateTrajectory(point){
      trajectoryPoints.push(point); 
      if(trajectoryPoints.length>300) trajectoryPoints.shift();
      if(trajectoryLine) scene.remove(trajectoryLine);
      if(trajectoryPoints.length>1){
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        trajectoryPoints.forEach(p=>{ vertices.push(p.x, p.y, 0); });
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        const material = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3, opacity:.7, transparent:true });
        trajectoryLine = new THREE.Line(geometry, material); 
        scene.add(trajectoryLine);
      }
    }

    function createMaxOpeningMarker(position){
      const geo = new THREE.SphereGeometry(5,16,16);
      const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity:.8, transparent:true });
      if(maxOpeningMarker) scene.remove(maxOpeningMarker);
      maxOpeningMarker = new THREE.Mesh(geo, mat); 
      maxOpeningMarker.position.set(position.x, position.y, 0); 
      scene.add(maxOpeningMarker);
    }

    // ===== FaceMesh =====
    function initFaceMesh(){
      faceMesh = new FaceMesh({ 
        locateFile: (file)=> `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` 
      });
      faceMesh.setOptions({ 
        maxNumFaces:1, 
        refineLandmarks:true, 
        minDetectionConfidence:.5, 
        minTrackingConfidence:.5 
      });
      faceMesh.onResults(onFaceMeshResults);
    }

    async function initCamera(){
      const video = document.getElementById('webcam');
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { width:1280, height:720, facingMode:'user' } 
        });
        video.srcObject = stream;
        camera = new Camera(video, { 
          onFrame: async ()=>{ await faceMesh.send({ image: video }); }, 
          width:1280, 
          height:720 
        });
        camera.start();
        
        // 립 마커 캔버스 초기화
        const lipCanvas = document.getElementById('lipMarkerCanvas');
        lipCanvas.width = window.innerWidth;
        lipCanvas.height = window.innerHeight;
        lipMarkerCtx = lipCanvas.getContext('2d');
        
        document.getElementById('loadingOverlay').style.display = 'none';
        updateStatus('카메라가 준비되었습니다. 시작 버튼을 눌러주세요.');
      }catch(err){ 
        console.error('카메라 접근 오류:', err); 
        updateStatus('카메라 접근 권한이 필요합니다.'); 
      }
    }

    function checkFaceInGuide(chinPos, nosePos){
      const cx = (chinPos.x + nosePos.x)/2; 
      const cy = (chinPos.y + nosePos.y)/2;
      return (cx>=GUIDE_BOUNDS.x.min && cx<=GUIDE_BOUNDS.x.max && 
              cy>=GUIDE_BOUNDS.y.min && cy<=GUIDE_BOUNDS.y.max);
    }

// ===== FaceMesh 결과 처리 (계속) =====
function onFaceMeshResults(results) {
  if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
    document.getElementById('faceStatus').textContent = '미감지';
    document.getElementById('guideStatus').textContent = '-';
    document.getElementById('faceGuide').classList.remove('active');
    document.getElementById('webcam').classList.remove('inverted');
    isFaceInGuide = false;
    currentLipPosition = null;
    if (lipMarkerCtx) {
      lipMarkerCtx.clearRect(0, 0, lipMarkerCtx.canvas.width, lipMarkerCtx.canvas.height);
    }
    return;
  }

  document.getElementById('faceStatus').textContent = '감지됨';
  const landmarks = results.multiFaceLandmarks[0];

  // 기본 랜드마크
  const chin = landmarks[CHIN_INDEX];
  const nose = landmarks[NOSE_TIP_INDEX];

  // 아랫입술 관련 랜드마크
  const lowerLipCenter = landmarks[LOWER_LIP_CENTER];
  const lowerLipLeft = landmarks[LOWER_LIP_LEFT];
  const lowerLipRight = landmarks[LOWER_LIP_RIGHT];
  const lowerLipBottom = landmarks[LOWER_LIP_BOTTOM];

  const chinPos = {
    x: (chin.x * window.innerWidth) - window.innerWidth / 2,
    y: -(chin.y * window.innerHeight) + window.innerHeight / 2,
    z: chin.z
  };
  const nosePos = {
    x: (nose.x * window.innerWidth) - window.innerWidth / 2,
    y: -(nose.y * window.innerHeight) + window.innerHeight / 2,
    z: nose.z
  };

  // 정확한 아랫입술 위치 계산 (여러 포인트의 평균)
  const lipX = (lowerLipCenter.x + lowerLipLeft.x + lowerLipRight.x + lowerLipBottom.x) / 4;
  const lipY = (lowerLipCenter.y + lowerLipLeft.y + lowerLipRight.y + lowerLipBottom.y) / 4;

  // 화면 좌표로 변환
  currentLipPosition = {
    x: lipX * window.innerWidth,
    y: lipY * window.innerHeight
  };

  // 위치 이력 관리 (스무딩)
  lipPositionHistory.push({ ...currentLipPosition });
  if (lipPositionHistory.length > 5) {
    lipPositionHistory.shift();
  }

  // 스무딩된 위치 계산
  if (lipPositionHistory.length > 0) {
    let sumX = 0, sumY = 0;
    lipPositionHistory.forEach(pos => {
      sumX += pos.x;
      sumY += pos.y;
    });
    currentLipPosition.x = sumX / lipPositionHistory.length;
    currentLipPosition.y = sumY / lipPositionHistory.length;
  }

  // 가이드 영역 체크
  isFaceInGuide = checkFaceInGuide(chinPos, nosePos);
  document.getElementById('guideStatus').textContent = isFaceInGuide ? '정렬됨' : '벗어남';
  document.getElementById('faceGuide').classList.toggle('active', isFaceInGuide);
  document.getElementById('webcam').classList.toggle('inverted', isFaceInGuide);

  // 교정 및 추적 로직
  if (isCalibrated && isTracking) {
    if (!chinRestPosition) {
      chinRestPosition = { ...chinPos };
      captureImage('jaw_calibration_start');
    }

    // 수직 개구량 계산
    currentVerticalOpening = Math.abs(chinPos.y - chinRestPosition.y);
    if (currentVerticalOpening > maxVerticalOpening) {
      maxVerticalOpening = currentVerticalOpening;
      createMaxOpeningMarker(chinPos);
    }

    // 궤적 업데이트
    updateTrajectory(chinPos);

    // 메트릭 업데이트
    const verticalMM = currentVerticalOpening * PIXELS_TO_MM;
    updateMetrics(verticalMM);

    // 턱 개방 상태 체크
    isJawTracking = currentVerticalOpening > JAW_OPEN_THRESHOLD;
  }

  // 립 마커 그리기
  drawLipMarker();
}

// ===== 교정 시작 =====
function startCalibration() {
  if (!isFaceInGuide) {
    updateStatus('얼굴을 가이드 영역에 맞춰주세요.');
    return;
  }

  setPhase('calibration');
  document.getElementById('startBtn').disabled = true;
  document.getElementById('resetBtn').disabled = false;
  document.getElementById('calibrationProgress').style.display = 'block';
  document.getElementById('instructions').style.display = 'block';
  document.getElementById('instructions').textContent = '입을 다문 상태로 3초간 유지해주세요.';

  calibrationSamples = [];
  let calibrationStartTime = Date.now();

  const calibrationInterval = setInterval(() => {
    if (!isFaceInGuide) {
      updateStatus('얼굴이 가이드 영역을 벗어났습니다.');
      clearInterval(calibrationInterval);
      resetSystem();
      return;
    }

    if (currentLipPosition) {
      calibrationSamples.push({ ...currentLipPosition });
    }

    let progress = (Date.now() - calibrationStartTime) / 3000;
    document.getElementById('calibrationBar').style.width = `${Math.min(progress * 100, 100)}%`;

    if (progress >= 1) {
      clearInterval(calibrationInterval);
      isCalibrated = true;
      setPhase('tracking');
      updateStatus('교정이 완료되었습니다. 입을 천천히 벌려 최대 개구량을 측정하세요.');
      document.getElementById('instructions').textContent = '입을 최대한 벌려주세요.';
      isTracking = true;
      document.getElementById('saveBtn').disabled = false;
      document.getElementById('downloadImagesBtn').style.display = 'block';
    }
  }, 100);
}

// ===== 시스템 초기화 =====
function resetSystem() {
  isCalibrated = false;
  isTracking = false;
  isJawTracking = false;
  isTrackingComplete = false;
  chinRestPosition = null;
  calibrationSamples = [];
  maxVerticalOpening = 0;
  currentVerticalOpening = 0;
  trajectoryPoints = [];
  lastJawPosition = null;
  currentLipPosition = null;
  lipPositionHistory = [];
  capturedImages = [];
  maxOpeningCaptured = false;

  setPhase('waiting');
  updateStatus('카메라가 준비되었습니다. 시작 버튼을 눌러주세요.');
  document.getElementById('startBtn').disabled = false;
  document.getElementById('resetBtn').disabled = true;
  document.getElementById('saveBtn').disabled = true;
  document.getElementById('calibrationProgress').style.display = 'none';
  document.getElementById('instructions').style.display = 'none';
  document.getElementById('lipTracking').style.display = 'none';
  document.getElementById('calibrationBar').style.width = '0%';
  document.getElementById('verticalDisp').textContent = '0.00 mm';
  document.getElementById('maxVerticalDisp').textContent = '0.00 mm';

  if (trajectoryLine) {
    scene.remove(trajectoryLine);
    trajectoryLine = null;
  }
  if (maxOpeningMarker) {
    scene.remove(maxOpeningMarker);
    maxOpeningMarker = null;
  }
  if (lipMarkerCtx) {
    lipMarkerCtx.clearRect(0, 0, lipMarkerCtx.canvas.width, lipMarkerCtx.canvas.height);
  }
}

// ===== 결과 저장 및 표시 =====
function saveResults() {
  if (!isCalibrated || !isTracking) {
    updateStatus('측정을 먼저 완료해주세요.');
    return;
  }

  isTracking = false;
  isTrackingComplete = true;
  setPhase('complete');
  updateStatus('측정이 완료되었습니다.');
  document.getElementById('instructions').style.display = 'none';
  document.getElementById('resultsPanel').style.display = 'block';

  const maxMM = (maxVerticalOpening * PIXELS_TO_MM).toFixed(2);
  document.getElementById('resultType').textContent = '최대 개구량 측정 완료';
  document.getElementById('finalMaxOpening').textContent = `${maxMM} mm`;
  document.getElementById('measurementTime').textContent = new Date().toLocaleString();
  document.getElementById('captureCount').textContent = capturedImages.length;
}

// ===== 결과 패널 닫기 =====
function closeResults() {
  document.getElementById('resultsPanel').style.display = 'none';
  resetSystem();
}

// ===== 초기화 =====
function init() {
  initThreeJS();
  initFaceMesh();
  initCamera();
}

window.onload = init;

    </script>
</body>
</html>